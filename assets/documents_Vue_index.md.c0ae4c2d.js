import{_ as e,v as t,b as a,R as o}from"./chunks/framework.a418d2ea.js";const m=JSON.parse('{"title":"Vue 组件通讯","description":"","frontmatter":{},"headers":[],"relativePath":"documents/Vue/index.md","filePath":"documents/Vue/index.md"}'),r={name:"documents/Vue/index.md"},i=o('<h1 id="vue-组件通讯" tabindex="-1">Vue 组件通讯 <a class="header-anchor" href="#vue-组件通讯" aria-label="Permalink to &quot;Vue 组件通讯&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Vue组件之间的通讯方式</p></div><h2 id="_1-props-emit-适用于父子组件通信" tabindex="-1">1.props/$emit 适用于父子组件通信 <a class="header-anchor" href="#_1-props-emit-适用于父子组件通信" aria-label="Permalink to &quot;1.props/$emit 适用于父子组件通信&quot;">​</a></h2><h2 id="_2-ref与-parent-children-适用于父子组件通信" tabindex="-1">2.ref与$parent/$children 适用于父子组件通信 <a class="header-anchor" href="#_2-ref与-parent-children-适用于父子组件通信" aria-label="Permalink to &quot;2.ref与$parent/$children 适用于父子组件通信&quot;">​</a></h2><blockquote><p>ref：如果在普通dom元素上使用，引用指向 $parent / $children 访问父 / 子 实例</p></blockquote><h2 id="_3-eventbus-emit-on-适用于父子、隔代、兄弟组件通信" tabindex="-1">3.EventBus($emit/$on)适用于父子、隔代、兄弟组件通信 <a class="header-anchor" href="#_3-eventbus-emit-on-适用于父子、隔代、兄弟组件通信" aria-label="Permalink to &quot;3.EventBus($emit/$on)适用于父子、隔代、兄弟组件通信&quot;">​</a></h2><blockquote><p>这种方法通过一个空的Vue实例作为中央事件总线(事件中心)，用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件</p></blockquote><h2 id="_4-attrs-listeners适用于隔代组件通信" tabindex="-1">4.$attrs/$listeners适用于隔代组件通信 <a class="header-anchor" href="#_4-attrs-listeners适用于隔代组件通信" aria-label="Permalink to &quot;4.$attrs/$listeners适用于隔代组件通信&quot;">​</a></h2><blockquote><p>$attrs：包含了父作用域中不被prop所识别（且获取）的特性绑定（class和style除外）。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定（class和style除外），并且可以通过v-bind=“$attes”传入内部组件。通常配合inheritAttrs选项一起使用。</p></blockquote><blockquote><p>$listeners：包含了父作用域中的（不含 .native修饰器的）v-on事件监听器，它可以通过v-on=“$listeners”传入组件内部</p></blockquote><h2 id="_5-provide-inject适用于隔代组件通信" tabindex="-1">5.provide/inject适用于隔代组件通信 <a class="header-anchor" href="#_5-provide-inject适用于隔代组件通信" aria-label="Permalink to &quot;5.provide/inject适用于隔代组件通信&quot;">​</a></h2><blockquote><p>祖先组件中通过provide来提供变量，然后再子孙组件中通过inject来注入变量。perovide/inject API主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p></blockquote><h2 id="_6-vuex适用于父子、隔代、兄弟组件通信" tabindex="-1">6.Vuex适用于父子、隔代、兄弟组件通信 <a class="header-anchor" href="#_6-vuex适用于父子、隔代、兄弟组件通信" aria-label="Permalink to &quot;6.Vuex适用于父子、隔代、兄弟组件通信&quot;">​</a></h2><blockquote><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式。每一个Vuex应用的核心就是store(仓库)。store基本上就是一个容器，它包含着你的应用中大部分的状态（state）。</p></blockquote><blockquote><p>Vuex的状态存储是响应式的。当Vue组件从store中度权益状态的时候，若store中的状态发生变化，那么相应的组件也会相应的得到更新。</p></blockquote><blockquote><p>改变store中的状态的唯一途径就是显示地提交（commit）mutation。这样使得我们可以方便的跟踪每一个状态的变化。</p></blockquote><h2 id="_7-消息订阅与发布" tabindex="-1">7.消息订阅与发布 <a class="header-anchor" href="#_7-消息订阅与发布" aria-label="Permalink to &quot;7.消息订阅与发布&quot;">​</a></h2><ol><li>安装pubsub：npm i pubsub-js</li><li>引入：import pubsub from ‘pubsub.js&#39;</li><li>接收数据：A组件想接受数据，则在A组件订阅消息，订阅回调留在A组件自身 pubsub.subscribe(&#39;xxxx&#39;,res=&gt;{})</li><li>提供数据：pubsub.publish(&#39;xxxx&#39;,data)</li></ol>',18),s=[i];function l(n,u,c,p,d,b){return t(),a("div",null,s)}const q=e(r,[["render",l]]);export{m as __pageData,q as default};
